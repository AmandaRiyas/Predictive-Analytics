# -*- coding: utf-8 -*-
"""notebook_Amanda_revisi.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nWEX_aav1ZM0j5lMIDFTYFRnoI8Lo_uN

# Predictive Analytics Project: [Prediksi Harga Tiket Pesawat]
- **Nama:** [Amanda Riyas Utami]
- **Email:** [amandariyas12@gmail.com]
- **ID Dicoding:** [MC223D5X0901]
- **Link Dataset:** https://www.kaggle.com/datasets/viveksharmar/flight-price-data

## Domain Proyek
Proyek ini berfokus pada penerapan machine learning untuk memprediksi harga tiket pesawat berdasarkan data historis yang tersedia secara publik. Industri penerbangan merupakan salah satu sektor dengan dinamika harga yang sangat tinggi, sehingga menjadi tantangan menarik dalam pengembangan model prediktif yang andal.
Dataset yang digunakan mencakup berbagai fitur seperti maskapai penerbangan, asal dan tujuan, durasi penerbangan, waktu keberangkatan dan kedatangan, serta jumlah transit. Fitur-fitur ini dinilai relevan karena secara logis memiliki pengaruh terhadap fluktuasi harga tiket.
Pada penelitian sebelumnya, prediksi harga tiket pesawat menggunakan Logistic Regression, Random Forest, dan Gradient Boosting menunjukkan bahwa Random Forest menghasilkan performa lebih baik dibanding dua model lainnya (Zebua et al., 2022). Berdasarkan hal tersebut, proyek ini mengimplementasikan tiga algoritma regresi K-Nearest Neighbors (KNN), Random Forest, dan Boosting Algorithm karena masing-masing memiliki keunggulan dalam menangani data.
Evaluasi performa model dilakukan menggunakan metrik Mean Squared Error (MSE), dan proses tuning dilakukan dengan pendekatan GridSearchCV dan RandomizedSearchCV untuk mengoptimalkan hasil prediksi.
Masalah ini harus diselesaikan karena ketidakakuratan prediksi harga tiket berdampak pada strategi bisnis perusahaan dan keputusan pembelian konsumen. Dengan model prediktif yang baik, perusahaan dapat mengoptimalkan penentuan harga dinamis, sementara konsumen dapat membuat keputusan pembelian yang lebih tepat waktu dan ekonomis.

## Business Understanding
Harga tiket pesawat memiliki fluktuasi yang tinggi karena dipengaruhi oleh beberapa faktor seperti maskapai pesawat yang digunakan, lokasi penerbangan, lokasi tujuan, durasi penerbangan, waktu keberangkatan, waktu tiba, dan total transit. Ketidakmampuan perusahaan untuk memprediksi harga secara akurat dapat menghambat pengambilan keputusan strategis seperti penentuan harga. Oleh karena itu, diperlukan model prediktif yang mampu memperkirakan harga tiket pesawat secara tepat berdasarkan pola data historis.

### Problem Statements
- Fluktuasi tinggi pada harga tiket pesawat menyulitkan perusahaan dalam menetapkan harga tiket pesawat karena ketidaktepatan dalam memprediksi harga dapat menghambat strategi harga dinamis.
- Perusahaan membutuhkan model prediktif berbasis data historis yang dapat membantu memproyeksikan harga tiket pesawat secara akurat.

### Goals
- Mengembangkan model prediksi harga tiket pesawat berdasarkan data historis dan variabel variabel relevan seperti maskapai pesawat yang digunakan, lokasi penerbangan, lokasi tujuan, durasi penerbangan, waktu keberangkatan, waktu tiba, dan total transit.
- Membandingkan performa beberapa algoritma machine learning regresi seperti K-Neares Neighbors (KNN), Random Forest, dan Boosting Algorithm untuk mendapat model dengan akurasi terbaik.

## Solution Statements
- Menerapkan beberapa pemodelan K-Nearest Neighbor, Random Forest, dan Boosting Algorithm untuk mencari tahu model terbaiknya dengan menambahkan evaluasi performa menggunakan Mean Squared Error (MSE)
- Melakuakan hyperparameter tuning menggunakan GridSearchCV dan RandomizedSearchCV
- Membandingkan performa dari model K-Nearest Neighbor, Random Forest, dan Boosting Algorithm.

### Variabel-variabel pada Flight Price Prediction adalah sebagai berikut:
- Airlines: Nama maskapai penerbangan yang mengoperasikan penerbangan tersebut.
- Source: Kota tempat penerbangan berangkat.
- Destination: Kota tempat mendarat.
- Total Stops: Jumlah pemberhentian yang dilakukan oleh penerbangan.
- Price: Harga tiket untuk masing-masing penerbangan.
- Date : Tanggal dimana penerbangan dijadwalkan.
- Month : Bulan dimanapenerbangan dijadwalkan
- Year: Tahun dimana penerbangan dijadwalkan.
- Dep_hours : Jam keberangkatan pesawat.
- Dep_min : Menit pada jam keberangkatan pesawat.
- Arrival_hours : Jam penerbangan tiba
- Arrival_min : Menit pada jam saat pesawat tiba
- Duration_hours : Durasi penerbangan dalam jam.
- Duration_min : Durasi penerbangan dalam menit

## Import Semua Packages/Library yang Digunakan
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import matplotlib.pyplot as plt
import pandas as pd
# %matplotlib inline
import seaborn as sns
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.neighbors import KNeighborsRegressor
from sklearn.metrics import mean_squared_error
from sklearn.ensemble import RandomForestRegressor
from sklearn.ensemble import AdaBoostRegressor
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
from sklearn.model_selection import GridSearchCV

"""## Data Loading"""

plane = pd.read_csv("https://raw.githubusercontent.com/AmandaRiyas/Predictive-Analytics-Project/refs/heads/main/flight_dataset.csv", sep=",")
plane.head()

"""## Data Understanding

### Exploratory Data Analysis - Deskripsi Variabel
"""

plane.info()

plane.isna().sum()

print("Jumlah duplikasi: ", plane.duplicated().sum())

plane.describe()

"""### Exploratory Data Analysis - Menangani Missing Value dan Outliers"""

# Pengecekan variabel Duration_hours
plane[plane['Duration_hours'] > 24]

# Drop baris dengan durasi di atas 24 jam
plane = plane[plane['Duration_hours'] <= 24]

"""- Menghapus `Duration_hours`yang melebihi 24 jam"""

# Pengecekan variabel Total_Stops
plane['Total_Stops'].value_counts()

"""- Terdapat 5153 data dengan Total_Stops 1
- Terdapat 3491 data dengan Total_Stops 0
- Terdapat 1096 data dengan Total_Stops 2
- Terdapat 20 data dengan Total_Stops 3
- Insight: Terdapat missing value terhadap Total_Stops yang lebih dari 2 karena pesawat biasanya hanya melakukan transit maksimal 2 kali.
"""

# Penanganan variabel Total_Stops
plane = plane[plane['Total_Stops'] <= 2]

"""- Total_Stops yang lebih dari 2 kali di hapus"""

# Pengecekan Duration_hours dengan Duration_min yang isinya 0 semua
plane[(plane['Duration_hours'] == 0) & (plane['Duration_min'] == 0)]

"""- Tidak ada penerbangan dengan waktu 0 jam 0 menit"""

plane.describe()

plane.head()

sns.boxplot(data=plane, x='Price')
plt.title('Boxplot of Ticket Prices')
plt.show()

"""- Terdapat banyak outlier dari data Price yang kemungkinan data Price yang dianggap oulier artinya tidak wajar tiket pesawat dengan harga segitu. Oleh karena itu sebaiknya dilakukan penghapusan outlier."""

# Hitung Q1, Q3 dan IQR
Q1 = plane['Price'].quantile(0.25)
Q3 = plane['Price'].quantile(0.75)
IQR = Q3 - Q1

# Hitung batas bawah dan batas atas
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Filter data yang tidak termasuk outlier
plane_no_outliers = plane[(plane['Price'] >= lower_bound) & (plane['Price'] <= upper_bound)]

# Boxplot setelah menghapus outlier
sns.boxplot(data=plane_no_outliers, x='Price')
plt.title('Boxplot of Ticket Prices (Outliers Removed)')
plt.show()

"""- Setelah dilakukan penghapusan outlier, terdapat masih ada 2 outlier yang sangat dekat dengan batas IQR, nilai ini sudah tidak perlu dihapus karena tidak terlalu berpengaruh untuk penganalisan selanjutnya sebab posisinya sudah sangat dekat dengan IQR.

### Exploratory Data Analysis - Univariate Analysis
"""

plane.info()

categorical_features = [
    'Airline', 'Source', 'Destination'
]

numerical_features = [
    'Total_Stops', 'Date', 'Month', 'Year','Dep_hours', 'Dep_min',
    'Arrival_hours', 'Arrival_min',
    'Duration_hours', 'Duration_min'
]

target = 'Price'

"""- Dilakukan pendefinisian pada `categorical_features` yang berisi variabel kategorik yaitu ada `Airline`, `Source`, dan `Destination`
- Dilakukan pendefinisian pada `numerical_features` yang berisi variabel numerik yaitu ada `Total_hours`, `Date`, `Month`, `Year`, `Dep_hours`, `Dep_min`, `Arrival_hours`, `Arrival_min`, `Duration_hours`, dan `Duration_min`
- Variabel `Price` menjadi target karena model ini nantinya akan digunakan untuk memprediksi harga
"""

for feature in categorical_features:
    count = plane[feature].value_counts().sort_index()
    percent = 100 * plane[feature].value_counts(normalize=True).sort_index()

    plane_categorical = pd.DataFrame({
        'Jumlah Sampel': count,
        'Persentase (%)': percent.round(1)
    })

    print(f"\n=== Fitur: {feature} ===")
    print(plane_categorical)

    count.plot(kind='bar', title=f'Distribusi {feature}', figsize=(8,4))
    plt.ylabel('Jumlah')
    plt.xlabel(feature)
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.show()

"""- Pada diagram batang distribusi `Airline` terhadap jumlah, maskapai dengan jumlah tertinggi yaitu Jet Airways dengan jumlah sebanyak 3377 dan yang terendah adalah maskapai Trujet dengan jumlah 1.
- Pada diagram batang distribusi `Source`terhadap jumlah, tempat keberangkatan tertinggi yaitu di Delhi dengan jumlah 4059 dan yang terendah di Chennai dengan jumlah 381
- Pada diagram batang distribusi `Destination`terhadap jumlah, tujuan destinasi tertinggi yaitu Cochin dengan jumlah 4059 dan yang terendah di Kolkata dengan jumlah 381.
"""

plane[numerical_features].hist(bins=50, figsize=(20, 15), color='#1f77b4', edgecolor='black')
plt.suptitle('Distribusi Fitur Numerikal', fontsize=16)
plt.tight_layout(rect=[0, 0.03, 1, 0.95])
plt.show()

"""- Dari diagram batang Distribusi `Total_Stops`, jumlah total stop tertinggi yaitu di angka 1 yang artinya pesawat hanya transit 1 kali dan total stop terendah di angka 2 yang artinya pesawat melakukan  2 kali transit
- Dari diagram batang distribusi `Date`, tanggal tertinggi berada di batang ke empat atau sekitar tanggal 8 dan yang terendah berada di batang ke 2 yaitu sekitar tanggal 3
- Dari diagram batang distribusi `month`, bulan dengan jumlah penerbangan tertinggi terjadi pada bulan 6 atau bulan Juni dan yang terendah yaitu pada bulan ke 4 atau bulan April.
- Dari diagram batang distribusi `Year` terlihat hanya ada satu batang yaitu di tahun 2019, yang artinya data hanya pada rentang tahin 2019.
- Dari diagram batang distribusi `Dep_hours` terlihat bahwa jam keberangkatan pesawat tertinggi terjadi pada jam 7 dan yang terendah pada jam 3.
- Dari diagram batang distribusi `Dep_min` terlihat bahwa menit keberangkatan pesawat tertinggi pada menit 0, artinya pesawat lebih sering berangkat di jam yang tepat todak lebih beberapa menit. Dan keberangkatan pesawat terendah di menit 40.
- Dari diagram batang distribusi `Arrival_hours` terlihat bahwa pesawat sering tiba di pukul 19 dan paling jarang tiba di pukul 6.
- Dari diagram batang distribusi `Arrival_min` terlihat bahwa pesawat sering tiba di menit 0 dan paling jarang tiba di menit 55.
- Dari diagram batang distribusi `Duration_hours` terlihat bahwa lama penerbangan paling sering yaitu selama 2 jam dan yang paling jarang yaitu selama 17 jam.
- Dari diagram batang distribusi `Duration_min` terlihat bahwa durasi menit dalam penerbangan paling sering di menit 30 dan yang paling jarang dengan durasi menit 10.
"""

plt.figure(figsize=(12, 6))
sns.boxplot(x='Airline', y='Price', data=plane_no_outliers, palette='Set3', showfliers=False)
plt.title('Distribusi Harga Tiket per Maskapai (Tanpa Outlier)')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

"""- Dari boxplot diagram `Airline` terhadap `Price` terlihat bahwa range harga terpanjang pada maskapai Jet Airways dengan menyediakan tiket paling murah hingga paling mahal dan range harga terpendek pada maskapai Trujet.

### Exploratory Data Analysis - Multivariate Analysis
"""

for col in categorical_features:
    sns.catplot(
        x=col,
        y="Price",
        kind="bar",
        data=plane_no_outliers,
        palette="Set3",
        height=4,
        aspect=3
    )
    plt.title(f"Rata-rata Harga (Price) terhadap Kategori '{col}'")
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.show()

"""- Dari diagram hubungan variabel `Airline` dengan `Price` terlihat bahwa maskapai dengan harga tertinggi yaitu Multiple carriers Premium economy dan yang terendah Trujet.
- Dari diagram hubungan variabel `Source` dengan `Price` terlihat bahwa harga lokasi keberangkatan termahal berada di Delhi dan yang paling murah di Mumbai
- Dari diagram hubungan variabel `Destination` dengan `Price` terlihat bahwa harga lokasi pendaratan termahal berada di New Delhi dan Cochin. Untuk yang termurah berada di Hyderabad
"""

features_for_corr = [
    'Total_Stops', 'Date', 'Month', 'Year','Dep_hours', 'Dep_min',
    'Arrival_hours', 'Arrival_min',
    'Duration_hours', 'Duration_min',
    'Price'
]

correlation_matrix = plane_no_outliers[features_for_corr].corr().round(2)
plt.figure(figsize=(10, 8))
sns.heatmap(
    data=correlation_matrix,
    annot=True,
    cmap='coolwarm',
    linewidths=0.5
)
plt.title("Correlation Matrix untuk Fitur Numerik dan Target", size=20)
plt.tight_layout()
plt.savefig("correlation_matrix.png")
plt.show()

"""- Korelasi terkuat pada variabel `Total_Stops` dan `Duration_hours`yaitu sebesar 0,67
- Korelasi terendah pada variabel -0 yaitu pada variabel `Date` dan `Arrival_hours`, variabel `Date` dan `Dep_min`, sertabvariabel `Date` dan `Total_Stops`. Nilai -0 ini artinya tidak ada korelasi sama sekali antar variabel
- Korelasi `Year` tidak terlihat karena isi tahun hanya sama

## Data Preparation

### Hapus Duplikat
"""

# Menghapus Duplikasi Data
plane = plane.drop_duplicates()
print("Jumlah setelah menghapus duplikasi: ", plane.shape)

"""- Dilakukan penghapusan data yang duplikat, setelah dihapus terdapat sisa data sebanyak 9579 data dengan 14 kolom

### Filter Data
"""

# Menggabungkan variabel date, month, year menjadi variabel Date_of_Journey
plane['Date_of_Journey'] = pd.to_datetime(
    plane['Date'].astype(str) + '-' +
    plane['Month'].astype(str) + '-' +
    plane['Year'].astype(str),
    format='%d-%m-%Y'
)

"""- Untuk mendapat hasil analisis yang lebih baik dilakukan penggabungan variabel `Date`, `Month`, dan `Year` menjadi variabel `Date_of_Journey`"""

# Membuat fitur turunan
plane['Day_of_week'] = plane['Date_of_Journey'].dt.dayofweek
plane['Is_weekend'] = plane['Day_of_week'].isin([5,6]).astype(int)

"""- Setelah penggabungan menjadi variabel `Date_of_Journey` dilakukan fitur turunan menjadi variabel `Day_of_week` untuk mengetahui di hari apa penerbangan di jadwalkan dan variabel `Is_weekend` untuk mengetahui apakah penerbangan dilakukan di hari weekend atau tidak"""

# Menghapus variabel Date, Month, dan Year
plane.drop(['Date', 'Month', 'Year'], axis=1, inplace=True)

"""- Karena `Date`, `Month`, dan `Year` sudah digabung maka ketiga variabel ini dihapus"""

# Menghapus variabel Date_of_Journey
plane.drop(['Date_of_Journey'], axis=1, inplace=True)

"""- Karena sudah dilakukan fitur turunan dari `Date_of_Journey` maka variabel ini dapat dihapus"""

# Menggabungkan Duration_hours dan Duration_min menjadi variabel Duration_total_min
plane['Duration_total_min'] = plane['Duration_hours'] * 60 + plane['Duration_min']

"""- Untuk memudahkan dalam penganalisisan maka variabel `Duration_hours` dan `Duration_min` digabung menjadi `Duration_total_min` untuk mengetahui durasi penerbangan dalam bentuk menit"""

# Menghapus variabel Duration_hours dan Duration_min
plane.drop(['Duration_hours', 'Duration_min'], axis=1, inplace=True)

"""- Karena variabel `Duration_hours` dan `Duration_min` sudah digabung maka kedua variabel ini dihapus"""

# Menggabungkan Arrival_hours dan Arrival_min
plane['Arrival_total_min'] = plane['Arrival_hours'] * 60 + plane['Arrival_min']

"""- Untuk mempermudah dalam menganalisis maka variabel `Arrival_hours` dan `Arrival_min` digabung dalam bentuk menit dan menghasilkan variabel `Arrival_total_min` dengan bentuk akhir dalam bentuk menit"""

# Menghapus variabel Arrival_hours dan Arrival_min
plane.drop(['Arrival_hours', 'Arrival_min'], axis=1, inplace=True)

"""- Karena variabel `Arrival_hours` dan `Arrival_min` sudah digabung maka variabel ini dapat dihapus"""

# Menggabungkan variabel Dep_hours dan Dep_min
plane['Dep_total_min'] = plane['Dep_hours'] * 60 + plane['Dep_min']

"""- Untuk mempermudah dalam menganalisis maka variabel `Dep_hours` dan `Dep_min` digabung menjadi `Dep_total_min` dengan bentuk akhir berupa menit"""

# Menghapus variabel Dep_hours dan Dep_min
plane.drop(['Dep_hours', 'Dep_min'], axis=1, inplace=True)

"""- Karena variabel `Dep_hours` dan `Dep_min` sudah digabung maka kedua variabel ini dapat dihapus"""

plane.info()

"""- Hail akhirnya terdapat 9579 data dengan 10 variabel yaitu variabel `Airline`, `Source`, `Destination`, `Total_Stops`, `Price`, `Day_of_week`, `Is_weekend`, `Duration_total_min`, `Arrival_total_min`, dan `Dep_total_min`"""

plane.head()

"""### Encoding Fitur Kategori"""

# Buat ulang plane_no_outliers dari plane yang sudah lengkap
Q1 = plane['Price'].quantile(0.25)
Q3 = plane['Price'].quantile(0.75)
IQR = Q3 - Q1
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

plane_no_outliers = plane[(plane['Price'] >= lower_bound) & (plane['Price'] <= upper_bound)]

"""- Karena ada perubahan variabel maka dilakukan pendefinisian ulang pada plane_no_outliers"""

categorical_features = [
    'Airline', 'Source', 'Destination'
]

numerical_features = [
    'Total_Stops', 'Day_of_week',
    'Is_weekend', 'Duration_total_min',
    'Arrival_total_min', 'Dep_total_min'
]

target = 'Price'

features = categorical_features + numerical_features
plane_model = plane_no_outliers[features + [target]].copy()

# One-hot encoding
plane_encoded = pd.get_dummies(plane_model, columns=categorical_features, dtype=int, drop_first=True)

print(plane_encoded.head())

"""- Melakukan encoding pada fitur kategorik

### Train-Test-Split
"""

X = plane_encoded.drop(["Price"], axis=1)
y = plane_encoded["Price"]

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.1, random_state=123
)

"""- Membagi data train dan test"""

print(f'Total # of sample in whole dataset: {len(X)}')
print(f'Total # of sample in train dataset: {len(X_train)}')
print(f'Total # of sample in test dataset: {len(X_test)}')

"""- Dari total 9487 data, sebanyak 8538 data untuk train, dan 949 data untuk test

### Standarisasi
"""

scaler = StandardScaler()
scaler.fit(X_train[numerical_features])

# Transform data latih dan uji
X_train[numerical_features] = scaler.transform(X_train[numerical_features])
X_test[numerical_features] = scaler.transform(X_test[numerical_features])
print(X_train[numerical_features].head())

"""- Untuk menyamakan skala fitur yanga ada dilakukan standarisasi"""

print(X_train[numerical_features].describe().round(4))

"""## Model Development

### K-Nearest Neighbor
"""

# Menyiapkan dataframe untuk analisis model
models = pd.DataFrame(index=['train_mse', 'test_mse'],
                      columns=['KNN', 'RandomForest', 'Boosting'])

# Inisialisasi dan latih model
knn = KNeighborsRegressor(n_neighbors=10)
knn.fit(X_train, y_train)

# Hitung MSE untuk train dan test
y_train_pred = knn.predict(X_train)
y_test_pred = knn.predict(X_test)

models.loc['train_mse', 'KNN'] = mean_squared_error(y_train, y_train_pred)
models.loc['test_mse', 'KNN'] = mean_squared_error(y_test, y_test_pred)

"""### Random Forest"""

RF = RandomForestRegressor(n_estimators=50, max_depth=16, random_state=55, n_jobs=-1)
RF.fit(X_train, y_train)

y_train_pred = RF.predict(X_train)
y_test_pred = RF.predict(X_test)

models.loc['train_mse', 'RandomForest'] = mean_squared_error(y_train, y_train_pred)
models.loc['test_mse', 'RandomForest'] = mean_squared_error(y_test, y_test_pred)

"""### Boosting Algorithm"""

# Inisialisasi dan latih model boosting
boosting = AdaBoostRegressor(learning_rate=0.05, random_state=55)
boosting.fit(X_train, y_train)

y_train_pred = boosting.predict(X_train)
y_test_pred = boosting.predict(X_test)

models.loc['train_mse', 'Boosting'] = mean_squared_error(y_train, y_train_pred)
models.loc['test_mse', 'Boosting'] = mean_squared_error(y_test, y_test_pred)

"""## Evaluasi Model"""

# Scaling X_test menggunakan scaler yang sudah fit dari X_train
X_test_scaled = X_test.copy()
X_test_scaled[numerical_features] = scaler.transform(X_test[numerical_features])

mse = pd.DataFrame(columns=['train', 'test'], index=['KNN','RF','Boosting'])

# Buat dictionary untuk setiap algoritma yang digunakan
model_dict = {'KNN': knn, 'RF': RF, 'Boosting': boosting}

# Hitung Mean Squared Error masing-masing algoritma pada data train dan test
for name, model in model_dict.items():
    mse.loc[name, 'train'] = mean_squared_error(y_true=y_train, y_pred=model.predict(X_train)) / 1e3
    mse.loc[name, 'test'] = mean_squared_error(y_true=y_test, y_pred=model.predict(X_test)) / 1e3

mse

fig, ax = plt.subplots()
mse.sort_values(by='test', ascending=False).plot(kind='barh', ax=ax, zorder=3)
ax.grid(zorder=0)
fig.savefig("plot_evaluasimetrik1.png")

"""- Dari evaluasi yang telah dilakukan nilai mse yang terbaik yaitu pada model Random Forest dan yang terburuk pada Boosting"""

prediksi = X_test.iloc[:1].copy()

pred_dict = {'y_true': y_test.iloc[:1].values[0]}
for name, model in model_dict.items():
    pred_dict[f'prediksi_{name}'] = model.predict(prediksi)[0].round(1)

pd.DataFrame([pred_dict])

"""- Prediksi yang terdekat dengan nilai aktual yaitu model KNN namun nilainya masih terlalu jauh sehingga diperlukan tuning model

## Tuning
"""

knn_params = {
    'n_neighbors': [3, 5, 10, 15],
    'weights': ['uniform', 'distance'],
    'p': [1, 2]
}

grid_knn = GridSearchCV(KNeighborsRegressor(), knn_params, cv=5, scoring='neg_mean_squared_error', n_jobs=-1)
grid_knn.fit(X_train, y_train)

best_knn = grid_knn.best_estimator_
print("Best KNN Params:", grid_knn.best_params_)

"""- Best parameter KNN yaitu ketika n_neighbors sebesar 10, p sebesar 1, dan weights nya uniform"""

from sklearn.model_selection import RandomizedSearchCV
from scipy.stats import randint
from sklearn.ensemble import RandomForestRegressor

rf_params = {
    'n_estimators': [50, 100, 150],
    'max_depth': [10, 16, 20],
    'min_samples_split': [2, 5],
    'min_samples_leaf': [1, 2],
    'max_features': ['sqrt', 'log2', None]
}

random_search = RandomizedSearchCV(
    RandomForestRegressor(random_state=55),
    rf_params,
    n_iter=20,
    cv=3,
    scoring='neg_mean_squared_error',
    n_jobs=-1,
    random_state=42
)

random_search.fit(X_train, y_train)
best_rf = random_search.best_estimator_
print("Best Params:", random_search.best_params_)

"""- Best parameter pada model random forest terjadi ketika n_estimators sebesar 50, min_samples_split nya 2, min_samples_leaf nya 2, max_features nya none, dan max_depth sebesar 10."""

boosting_params = {
    'n_estimators': [50, 100, 200],
    'learning_rate': [0.01, 0.05, 0.1, 0.2],
    'loss': ['linear', 'square', 'exponential']
}

grid_boost = GridSearchCV(AdaBoostRegressor(random_state=55), boosting_params, cv=5, scoring='neg_mean_squared_error', n_jobs=-1)
grid_boost.fit(X_train, y_train)

best_boost = grid_boost.best_estimator_
print("Best Boosting Params:", grid_boost.best_params_)

"""- Best parameter pada Boosting yaitu ketika learning_rate nya 0.01, loss nya linear, dan n_estimators nya 200"""

model_dict = {
    'KNN': best_knn,
    'RF': best_rf,
    'Boosting': best_boost
}

"""- Membuat dictionary model

## Evaluasi Setelah Tuning
"""

from sklearn.metrics import mean_squared_error
eval_mse = pd.DataFrame(columns=['train_MSE', 'test_MSE'])

for name, model in model_dict.items():
    y_train_pred = model.predict(X_train)
    y_test_pred = model.predict(X_test)

    eval_mse.loc[name, 'train_MSE'] = mean_squared_error(y_train, y_train_pred)
    eval_mse.loc[name, 'test_MSE'] = mean_squared_error(y_test, y_test_pred)
print(eval_mse)

eval_mse_sorted = eval_mse.sort_values('test_MSE', ascending=False)

fig, ax = plt.subplots(figsize=(8, 5))
eval_mse_sorted[['train_MSE', 'test_MSE']].plot(kind='barh', ax=ax, zorder=3)

ax.set_title("MSE Model Setelah Tuning")
ax.set_xlabel("Mean Squared Error")
ax.set_ylabel("Model")
ax.grid(zorder=0)
plt.tight_layout()
plt.show()

"""- Dari evaluasi ketiga model setelah tuning Random Forest adalah model terbaik karena nilai MSE paling rendah diantara model yang lain"""

prediksi = X_test_scaled.iloc[:1].copy()
pred_dict = {'y_true': y_test.iloc[:1].values[0]}

for name, model in model_dict.items():
    pred_dict[f'prediksi_{name}'] = model.predict(prediksi)[0].round(1)

pd.DataFrame([pred_dict])

"""- Nilai prediksi Boosting Algorithm lebih mendekati nilai aktual dibandingkan dengan KNN dan Random Forest

##Kesimpulan:##
Meskipun pada prediksi yang terbaik adalah Boosting Algorithm namun Random Forest adalah model yang terbaik karena nilai MSE terkecil. Sebab lebih baik mengutamakan kestabilan error individual dari pada perbandingan nilai prediksi dan nilai aktual
"""